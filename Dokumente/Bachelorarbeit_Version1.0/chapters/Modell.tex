% Main chapter 3:
% Modell 

\chapter{Prozess}
\label{chap:Model}
Das Kapitel \ref{chap:Model} befasst sicht mit der Modellbildung bezüglich der entwickelten Methodik. Das Ziel des Verfahrens ist die Gewinnung der systembeschreibenden Zustandsautomaten aus formalisierten Anforderungen. Dazu wird in Abschnitt \ref{sec:Overview_Model} zuerst eine Übersicht über dieses gegeben. Anschließend werden in Abschnitt \ref{sec:lib_algo} die verwendeten Bibliotheken und Algorithmen angesprochen. Nachdem in Abschnitt \ref{sec:support_proc} die unterstützenden Prozesse abgehandelt worden sind folgt in Abschnitt \ref{sec:core_proc} der Kernprozess. Schlussendlich werden in Abschnitt \ref{sec:ext_FSM} noch zwei sturkturelle Erweiterungen zur klassischen Finite State Machine eingeführt.

\section{Übersicht über den Gesamtprozess}
\label{sec:Overview_Model}
Die Intention des Abschnittes \ref{sec:Overview_Model} ist es die Zusammenhänge zwischen den einzelnen Bausteinen des Verfahren herzustellen (Unterabschnitt \ref{subsec:ClassDiagram_Model}) und deren Zusammenwirken mittels des Ablaufdiagramms (Unterabschnit \ref{subsec:Flowchart_Model}) darzustellen. Abschließend folgt in Unterabschnitt \ref{subsec:ex_exp_proc} eine kurze Einführung zweier Beispiel-Requirements.
\subsection{Klassendiagramm des Modells}
\label{subsec:ClassDiagram_Model}
Abschnitt \ref{subsec:UML} hat sich mit den Grundlagen des Klassendiagramms als Ausprägung eines Strukturdiagramms beschäftigt. Das Klassendiagramm stellt die statische Struktur, insbesondere die Klassen und ihre Beziehungen zueinander dar. Das Klassendiagramm, welches dem in dieser Arbeit entwickelten Modell zugrunde liegt, ist in Abbildung \ref{img:ClassDiagram_Model} aufgezeigt.\\
\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{images/ClassDiagram.pdf}
	\caption{Klassendiagramm des Modells}
	\label{img:ClassDiagram_Model}
\end{figure}
Das Management der Anforderungen erfolgt in IBM\textsuperscript{\textregistered} Rational\textsuperscript{\textregistered} Doors\textsuperscript{\textregistered}. Die Bereitstellung für das Design Cockpit 43\textsuperscript{\textregistered} erfolgt via dem RequirementsInterchangeFormat (ReqIF). Aufgrund der Zuweisung des Objekt-Typs in Doors\textsuperscript{\textregistered} werden beim Import der ReqIF-Datei automatisch die entsprechenden Instanzen der Klassen der linken Spalte des Klassendiagramms (ReqIFSys, VehicleFunction, Requirement, TestCase, BaseScenario, TestStep) erzeugt. Ein ReqIFSys[tem] hat dabei beliebig viele VehicleFunction[s], welche wiederrum beliebig viele Requirement[s] besitzen. Jedem Requirement können beliebig viele TestCase[s] zugeordnet werden. Ein TestCase besteht aus aus beliebig vielen BaseScenario[s] und TestStep[s]. Die Struktur des aus der ReqIF-Datei entstehendem Systems ist jedoch nicht der Fokus dieser Arbeit und somit sei für eine genauere Beschreibung dieses  auf das Paper von Walter et al. \cite{WHPR17} verwiesen. Die Elimination von redundanten Testfällen (TestCase[s]) und das infolge dessen notwendige Clustering und Neuanordnen dieser ist ebenfalls Gegenstand bereits von Walter et al. behandelt worden \cite{WSPR17} und wird deshalb ebenso nicht im Rahmen der vorliegenden Arbeit näher beleuchtet. Eine ausführliche Beschäftigung mit den übrigen Klassen im Diagramm erfolgt in den nächsten Abschnitten innerhalb dieses Kapitels.
Neben den VehicleFunction[s] hat das ReqIfSys[tem] auch noch 1 bis N SystemStateMachine[s], wobei N eine natürliche Zahl ist. Mehrere systembescheibende Zustandsautomaten eines Systems können entstehen, indem die im Lastenheft aufgeführte Requirements mehr als ein unabhängiges System beschreiben. Die SystemStateMachin baut sich aus mindestens einer normalerweise jedoch N AtomicRequirementStateMachine[s] auf. Die AtomicRequirementsStateMachine[s] enstehen aus der Atomarisierung der RequirementStateMachine[s]. Daraus folgt sofort, dass auch jede RequirementStateMachine 1 bis N AtomicRequirementStateMachine[s] besitzt. Eine RequirementStateMachine ist ein Zustandsautomat, der ein einziges Requirement beschreibt. Somit hat jedes Requirement genau eine RequirementStateMachine. Sowohl die AtomicRequirementStateMachine als auch die RequirementStateMachine setzten sich jeweils aus 1 bis N RequirementStates und Requirement State Transitions zusammen. RequirementStateTransition[s] beschreiben den Übergang  von einem Zustand (RequirementState) innerhalb der RequirementStateMachine zum nächsten. Da Zustände abhängig vom Eingang (Input) unterschiedliche nächste Zustände, oder im Falle eines Endzustandes gar keinen, haben können die Transition jedoch einen eindeutigen Übergang liefers soll, besitzt ein RequirementState 0 bis N RequirementStateTransition[s], eine RequirementStateTransition jedoch nur 1 RequirementState. Ein RequirementState besitzt als Bausteine 1 bis N atomare Zustände (AtomicStates). Analog zu der Requirement-Ebene setzt sich auch die AtomicStateMachine aus sowohl aus 1 bis N AtomicState[s] als auch aus 1 bis N AtomicStateTransitions zusammen. Ebenfalls kann ein AtomicState 0 bis N AtomicStateTransitions haben, die AtomicStateTransition hingegen nur 1 AtomicState. Der atomare Zustand wird durch 1 Parameter und 1 Value aus dem Werteraum dieses Parameters vollständig beschrieben. 
\subsection{Ablaufdiagramm des Prozesses}
\label{subsec:Flowchart_Model}
Das Ablaufdiagramm (Abbildung \ref{img:Flowchart_Model}) beschreibt den Prozess von der natürlich sprachlichen Andorderung bis hin zum systembeschreibenden Zustandsautomaten. Eine nähere Betrachtung der einzelnen Schritte beziehungsweise der Übergänge von einem Zwischenergebnis zum nächsten wird in den folgenden Abschnitten behandelt.\\
\begin{figure}
	\centering
	\includegraphics[width=0.99\textwidth]{images/Ablaufdiagramm171205.pdf}
	\caption{Ablaufdiagramm des Modells}
	\label{img:Flowchart_Model}
\end{figure}
Am Anfang stehen dabei die Requirements in natürlicher Sprache. Die Beschreibung der natürlichsprachlichen Requirements in Specification Patterns System erfolgt manuell. Die Atomarisierung-Bibliothek legt die atomarisierbaren Zustände fest. Durch einen Substitutionsvorgang und mit Hilfe einer Abbildungsbibliothek erfolgt der Übergang der Requirements-Beschreibung von Specification Patterns in Lineare Temporal Logik (LTL). Die Resultate der Substitution werden in einer Substitut-Datenbank abgelegt. Aus dieser werden die enthaltenen Parameter mit ihren Werteräume extrahiert. Anhand der Paarungen von Parametern und Werten sind die Atomic State Machines erstellbar. Bevor die Abbildungsbibliothek von LTL nach First Order Logic (FOL) in das System einkoppelt, können durch Anwenden einen Sortieralgorithmus die Ausdrücke von FOL in eine Konjunktive Normalform (CNF) überführt werden. Diese bilden zusammen mit den Beschreibungen der Requirements in Linearer Temporal Logik und den Atomic State Machines die Requirement State Machines. Die Atomarisierung dieser in Atomic Requirement State Machine erfolgt unter erneuter Anwendung der Atomarisierungs-Bibliothek und der Substitut-Datenbank. Schlussendlich werden durch eine Synthese die Atomic Requirement State Machines zu mindestens einer System State Machine zusammengefügt.
\subsection{Beispiel-Requirements zur Erläuterung des Prozesses}
\label{subsec:ex_exp_proc}
Inhalt dieses Unterabschnittes ist es zwei beispielhafte Requirements vorzustellen. Diese sollen in den folgenden Abschnitten beziehungsweise Unterabschnitten herangezogen werden um die aufgeführten Erläuterungen bezüglich der einzelnen Schritte zu unterstreichen. Dabei werden die Requirements sowohl in natürlicher Sprache als auch in Specification Pattern angegeben.
\subsubsection{Beispiel-Requirement 1}
\label{subsubsec:ex_req_1}
Die natürlichsprachliche Beschreibung des ersten Beispiel-Requirements ist wie folgt:
\begin{quote}
	"`Durch drehen des Schlüssels im Zündschloss in die Position ON wird die Spannungsversorgung sowohl für die Zündung als auch für die Verbraucher eingeschaltet."' 
\end{quote}
Ausgedrückt im Specification Pattern System ergibt sich das Requirement zu:
\begin{quote}
	"`(PowerSupplyIgnition[ON] and PowerSupplyConsumer[ON]) is true after IgnitionKeyLockPosition[ON] "' 
\end{quote}
\subsubsection{Beispiel-Requirement 2}
\label{subsubsec:ex_req_2}
Die natürlichsprachliche Beschreibung des zweiten Beispiel-Requirements ist wie folgt:
\begin{quote}
	"`Nachdem der Lichtdrehschalter in die Position Außenlicht ein bewegt worden ist darf das Ablendlicht nicht aktiviert werden bevor die Spannungsversorgung für die Verbraucher und die Zündung anliegt."' 
\end{quote}
Ausgedrückt im Specification Pattern System ergibt sich das Requirement zu:
\begin{quote}
	"`(PowerSupplyIgnition[ON] and PowerSupplyConsumer[ON]) precedes (LowBeamHeadlightLeft[ON] and LowBeamHeadlightRight[ON]) after RotaryLightSwitchPosition[ExteriorLightON] "' 
\end{quote}
\section{Bibliotheken und Algorithmen}
\label{sec:lib_algo}
Ziel dieses Abschnittes ist es die, für den Prozess, benötigen Blbliotheken und Algorithmen kurz einzuführen. Dazu wird zuerst die Atomarisierungsbibliothek (Unterabschnitt \ref{subsec:atomization_lib}) angesprochen. Daraufhin folgt die Abbildungbibliothek von SPS zu LTL in Unterabschnitt \ref{subsec:sps2ltl_lib}. Abschließend wird die Abbildungsbibliothek von LTL zu FOL (Unterabschnitt \ref{subsec:ltl2fol_lib}) und der damit eng verwobene Sortier-Algorithmus von FOL zu CNF (Unterabschnitt \ref{subsec:fol2cnf_sort_algo}).
\subsection{Atomarisierungs-Bibliothek}
\label{subsec:atomization_lib}
Die Atomarisierungs-Bibliothek ist eine kleine, aber wichtige Biblbiothek. Diese gibt an welche Requirement States, die (wie bereits besprochen in Unterabschnitt \ref{subsec:ClassDiagram_Model}), aus Atomic State zusammengesetzt sind, sich in ihre atomaren Bestandteile zerlegen lassen. Für das Precedence-Pattern gelten die Regeln aus Tabelle \ref{tab:atom_precedence} zur Atomarisierung. Demnach lässt sich die Variable P (Platzhalter für einen Requirement State) atomarisieren. Eine vollständige Auflistung aller Specification Pattern ist Tabelle \ref{tab:atom_lib} in Unterabschnitt \ref{subsec:app_atomization_lib} des Appendix \ref{chap:AppendixB} zu entnehmen.\\
\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{p{0.22\textwidth}|p{0.22\textwidth}|p{0.22\textwidth}|p{0.22\textwidth}}
		\hline
		Specification\newline Pattern & Ausdruck & atomarisierbar & nicht \newline atomarisierbar \\ \hline
		Precedence & S precedes P [...] & P & S \\ 
	\end{tabularx}
	\caption{Atomarisierungs-Bibliothek bezüglich des Precedence-Pattern}
	\label{tab:atom_precedence}
\end{table}
Die drei theoretischen möglichen Atomarisierungen bezüglich des zweiten Beispiel-Requirements (Unterabschnitt \ref{subsubsec:ex_req_2}) wären:
\begin{itemize}
	\item \textbf{AtomicPattern I}: (PowerSupplyIgnition[ON]) precedes (LowBeamHeadlightLeft[ON] and LowBeamHeadlightRight[ON]) after\newline RotaryLightSwitchPosition[ExteriorLightON]\\ \textbf{AtomicPattern II}: (PowerSupplyConsumer[ON]) precedes (LowBeamHeadlightLeft[ON] and LowBeamHeadlightRight[ON]) after\newline RotaryLightSwitchPosition[ExteriorLightON]
	\item \textbf{AtomicPattern I}: (PowerSupplyIgnition[ON] and PowerSupplyConsumer[ON]) precedes LowBeamHeadlightLeft[ON] after\newline RotaryLightSwitchPosition[ExteriorLightON]\\ \textbf{AtomicPattern II}: (PowerSupplyIgnition[ON] and PowerSupplyConsumer[ON]) precedes (LowBeamHeadlightRight[ON]) after\newline RotaryLightSwitchPosition[ExteriorLightON]
	\item \textbf{AtomicPattern I}: PowerSupplyIgnition[ON] precedes LowBeamHeadlightLeft[ON] before RotaryLightSwitchPosition[ExteriorLightON]\\ 
	\textbf{AtomicPattern II}: PowerSupplyIgnition[ON] precedes LowBeamHeadlightRight[ON] after RotaryLightSwitchPosition[ExteriorLightON]\\
	\textbf{AtomicPattern III}: PowerSupplyConsumer[ON] precedes LowBeamHeadlightLeft[ON] before RotaryLightSwitchPosition[ExteriorLightON]\\ 
	\textbf{AtomicPattern IIII}: PowerSupplyConsumer[ON] precedes LowBeamHeadlightRight[ON]) after RotaryLightSwitchPosition[ExteriorLightON]
\end{itemize}
Die dritte Möglichkeit wird dabei generell ausgeschlossen, da in diesem Fall die Abhängigkeiten zwischen der Spannungsversorgung und des Ablendlichts bekannt sein müssen. Diese gehen aber aus den Specification Patterns nicht hervor. Beispielsweise macht eine Abhängigkeit des linken Ablendlichts von wahlweise der Spannungsversorgung der Verbaucher oder derjenigen der Zündung wenig Sinn.\\
Die zweite Möglichkeit wird auch nicht als zulässig erklärt. Ebenfalls wird dies mit der fehlenden Information der Specification Patterns bezüglich der Abhängigkeiten begründet. Für den menschlichen Benutzer ist eine Abhängigkeit bezüglich der Spannungsversorgung der Verbaucher und des Ablendlichts schnell offensichtlich, maschinell ist dies aber schwierig zu entscheiden.\\
Somit bleibt nur noch die erste Möglichkeit. Es kann gefahrlos angenommen werden, dass weder dass linke noch das rechte Ablendlicht aktiviert werden können bevor die Stromversorgung anliegt.
\subsection{Abbildungs-Bibliothek von SPS zu LTL}
\label{subsec:sps2ltl_lib}
Die Abbildungs-Bibliothek von SPS zu LTL bereitgestellt von Dwyer et al. ist bereits in Unterabschnitt \ref{subsec:genPatterns} vorgestellt worden. Tabelle \ref{tab:extract_sps2ltl_lib} liefert einen Ausschnitt aus dieser. Für die Bibliothek sei auf Internetseite des Specification Pattern Systems verwiesen \cite{DACDAP17}.\\
\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{p{0.20\textwidth}|p{0.29\textwidth}|p{0.40\textwidth}}
		\hline
		Specification\newline Pattern & Ausdruck & LTL \\ \hline
		Universality & P is true after Q & $\square$(Q $\rightarrow$ $\square$(P)) \\ 
	\end{tabularx}
	\caption{Abbildungs-Bibliothek von SPS zu LTL (Ausschnitt) \cite{DACDAP17}}
	\label{tab:extract_sps2ltl_lib}
\end{table}
Beispielhaft ergibt sich für den SPS Ausdruck des ersten Beispiel-Requirements der LTL-Ausdruck zu:
\begin{quote}
	"`$\square$(IgnitionKeyLockPosition[ON] $\rightarrow$ $\square$(PowerSupplyIgnition[ON] and PowerSupplyConsumer[ON])) "' 
\end{quote}
\subsection{Abbildungs-Bibliothek von LTL zu FOL (FSM)}
\label{subsec:ltl2fol_lib}
Die Abbildungs-Bibliothek von LTL zu FOL regelt den Übergang von der Notation der Linearen Temporal Logik in Prädikatenlogik. Walter et al. \cite{WHPR17} hat bereits im Rahmen der Formalisierung von Tests die Ausprägung linear temporal logischer Ausdrücke auf First Order Logic auf Basis einer vorwärts gerichteten verketteten Liste illustriert. Auf Grundlage der Erkenntnisen aus Unterabschnitt \ref{subsec:FormProcLang} bedarf es bei Requirements einer flexibleren Lösung.\\
Ausgehend von der Abbildung linear temporal logischer Ausdrücke auf Büchi Automaten (beispielsweise von Gastin et al. \cite{GP01} oder Lu et al. \cite{LL12} behandelt) und einem zustandsorientiertem Fokus ist im Rahmen der vorliegenden Arbeit eine Abbildungsvorschrift von LTL zu FOL entwickelt worden. Ein Auszug aus dieser Abbildungs-Bibliothek ist Tabelle \ref{tab:extract_ltl2fol_lib} entnehmen. Die vollständige Abbildungsbibliothek aller Specification Pattern ist Tabelle \ref{tab:ltl2fol_lib} in Unterabschnitt \ref{subsec:app_ltl2fol_lib} des Appendix \ref{chap:AppendixB} zu entnehmen.
\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{|p{0.47\textwidth}|p{0.475\textwidth}|}
		\hline
		LTL & FOL (FSM) \\ \hline
		G(Q I G (P)) & \includegraphics[width=0.3\textwidth]{images/P_is_true_after_Q.png} \\ \hline
		G NOT Q OR M (NOT P U \newline(S OR G NOT P)) & \includegraphics[width=0.3\textwidth]{images/S_precedes_P_after_Q.png} \\ \hline
		\multicolumn{2}{|c|}{\hspace{0.5cm}\includegraphics[width=0.3\textwidth]{images/LTL2FSM_description.pdf}} \\ \hline
	\end{tabularx}
	\caption{Abbildungs-Bibliothek von LTL zu FOL (Ausschnitt)}
	\label{tab:extract_ltl2fol_lib}
\end{table}
Die First Order Logic beziehungsweise Finite State Machine Repräsentation der beiden Beispiel-Requirements sind Abbildung \ref{imag:ex_req_FSM} zu entnehmen.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{images/Ex_Req_1.pdf}\\
	\includegraphics[width=0.6\textwidth]{images/Ex_Req_2.pdf}
	\caption{Finite State Machines der Beispiel-Requirements}
	\label{imag:ex_req_FSM}
\end{figure}
\subsection{Sortier-Algorithmus zum Erhalt der CNF aus der FOL}
\label{subsec:fol2cnf_sort_algo}
Der Sortier-Algorithmus zum Erhalt der CNF formt die Ausdrücke aus den verschiedenen Zuständen in die konjunktive Normalform um. Der Ausdruck in FOL muss dabei Gleichung \ref{eq:CNF} genügen.
Beispielhaft wäre der CNF-Ausdruck des Zustands "`\textit{NOT (LowBeamHeadlightLeft[ON] and LowBeamHeadlightRight[ON])}"' der zweiten Beispiel-FSM "`\textit{(NOT LowBeamHeadlightLeft[ON] and NOT LowBeamHeadlightRight[ON])}"'. 
\section{Unterstützungsprozess}
\label{sec:support_proc}
\subsection{Substitution und Substitut-Datenbank}
\label{subsec:substitution_database}
\subsection{Parameter-Liste}
\label{subsec:parameter_list}
\subsection{Atomic State Machine}
\label{subsec:ASM}
\section{Kernprozess}
\label{sec:core_proc}
\subsection{Requirement in natürlicher Sprache}
\label{subsec:req_NL}
\subsection{Requirement in Specification Pattern}
\label{subsec:req_SPS}
\subsection{Requirement in LTL}
\label{subsec:req_LTL}
\subsection{Requirement State Machine}
\label{subsec:RSM}
\subsection{Atomic Requirement State Machine}
\label{subsec:ARSM}
\subsection{System State Machine}
\label{subsec:SSM}
\section{Strukturelle Erweiterungen der FSM}
\label{sec:ext_FSM}
\subsection{Counter}
\label{subsec:ext_FSM_counter}
\subsection{Timer}
\label{subsec:ext_FSM_timer}